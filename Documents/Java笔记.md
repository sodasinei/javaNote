# Java笔记

p11<img src="C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230307230604328.png" alt="image-20230307230604328" style="zoom:50%;" />

![image-20230307231931023](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230307231931023.png)

p18

![image-20230309172439010](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230309172439010.png)

![image-20230309173002688](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230309173002688.png)

0019

如何学习一门新技术，顺时针看

![image-20230310103050862](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230310103050862.png)

0020

> ![image-20230310103657525](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230310103657525.png)在cmd里面用

\代表转义字符

0024 文档注释

![image-20230311105022971](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230311105022971.png)

0025

![image-20230311105910709](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230311105910709.png)

0026

md是创建一个文件夹，rd是删除

![image-20230311111003786](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230311111003786.png)

0027

..意思是返回到上一级目录

abc的意思就是目录

![image-20230311112307568](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230311112307568.png)

0028

![image-20230311114111980](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230311114111980.png)

0029

<img src="C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230311114648888.png" alt="image-20230311114648888" style="zoom:50%;" />

38

![image-20230316145754762](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230316145754762.png)

39

![image-20230316145904678](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230316145904678.png)

0041

![image-20230315232117935](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230315232117935.png)

0044

![image-20230315233625459](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230315233625459.png)

num12的值是一个接近2.7的小数。计算机对于小数的处理并不精确。![image-20230315234846883](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230315234846883.png)

45

![image-20230316151858685](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230316151858685.png)

直接索引找类，在类里找方法

46

![image-20230316153212084](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230316153212084.png)

47

![image-20230318191259257](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230318191259257.png)

48

![image-20230318194330429](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230318194330429.png)

50

<img src="C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230318195217675.png" alt="image-20230318195217675" style="zoom:50%;" />

56

![image-20230319183210639](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230319183210639.png)

运算会当做int类型

57

基本类型转字符串类型。直接在值后面+""

![image-20230319200706828](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230319200706828.png)

​	字符串转基本类型

![image-20230319201515516](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230319201515516.png)

Integer是一个包装类，parsexx是一个方法。

60

![image-20230319220308678](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230319220308678.png)

64

![image-20230319223619447](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230319223619447.png)

70

![image-20230323133308363](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230323133308363.png)

71

![image-20230323134254999](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230323134254999.png)

81

![image-20230323160248770](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230323160248770.png)

83

![image-20230323160848697](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230323160848697.png)

85

![image-20230323161920624](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230323161920624.png)

![image-20230323163742184](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230323163742184.png)

0102

![image-20230323201032396](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230323201032396.png)

按位与的位指的就是bit

0111

![image-20230325143409375](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230325143409375.png)

里头的b被赋值成了false，最后输出c

0112

![image-20230325204909716](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230325204909716.png)

0117

![image-20230325213258467](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230325213258467.png)

**double类型不行**

![image-20230325215229108](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230325215229108.png)

0124

![image-20230407192228413](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230407192228413.png)

> ```java
> public class ForExercise {
> //编写一个 main 方法
> public static void main(String[] args) {
> //打印 1~100 之间所有是 9 的倍数的整数，统计个数 及 总和.[**化繁为简,先死后活**]
> //老韩的两个编程思想(技巧)
> //1. 化繁为简 : 即将复杂的需求，拆解成简单的需求，逐步完成 编程 = 思想 --练习-> 代码
> //2. 先死后活 : 先考虑固定的值，然后转成可以灵活变化的值
> //
> //思路分析
> //打印 1~100 之间所有是 9 的倍数的整数，统计个数 及 总和
> //化繁为简
>     //(1) 完成 输出 1-100 的值
> //(2) 在输出的过程中，进行过滤，只输出 9 的倍数 i % 9 ==0
> //(3) 统计个数 定义一个变量 int count = 0; 当 条件满足时 count++;
> //(4) 总和 , 定义一个变量 int sum = 0; 当条件满足时累积 sum += i;
> //先死后活
> //(1) 为了适应更好的需求，把范围的开始的值和结束的值，做出变量
> //(2) 还可以更进一步 9 倍数也做成变量 int t = 9;
>     int count = 0; //统计 9 的倍数个数 变量
> int sum = 0; //总和
> int start = 10;
> int end = 200;
> int t = 5; // 倍数
> for(int i = start; i <= end; i++) {
> if( i % t == 0) {
> System.out.println("i=" + i);
> count++;
> sum += i;//累积
> }
> }
> System.out.println("count=" + count);
> System.out.println("sum=" + sum);
> }
> }
> ```

**水平的高低一个很重要的能力的体现就在于：拆解能力，能否将别人给你的需求拆解为几个简单的需求。**

0125

![image-20230407204342364](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230407204342364.png)

```java
public class ForExercise02 {
//编写一个 main 方法
public static void main(String[] args) {
//化繁为简
//先死后活
int n = 9;
for( int i = 0; i <= n; i++) {
System.out.println(i + "+" + (n-i) + "=" + n);
}
}
}
```

**内存分析图也是编程思想**

0132

![image-20230408103245535](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230408103245535.png)

```java
import java.util.Scanner;
//1.循环还钱吗
//2.接受答案
//3.如果条件是y,则退出循环
public class DWExercise{
	public static void main(String[]args){
		Scanner myScanner = new Scanner(System.in);
		
		char answer = ' ';
		do{

			System.out.println("还钱吗");
			answer = myScanner.next().charAt(0);
			System.out.println("回答是" + answer);
		}while(answer != 'y');
	}
}
```

0134

尽量每定义一个变量时顺带初始化，否则后面运算容易报错

0136

print打印不换行，println打印一次换行

打印空心金字塔：

```java
public class Stars{
	public static void main (String[] args) {
		int i,j;
		/*
			*     1.第一层1个*  前面空格数4
		   * *		2.   3       		3
		  *   *		3. 	 5				2
		 *     *	4    7				1
		*********	5.   9				0
		*/
		for(i = 1;i <= 5;i++) {	//层数
			for(int k =1;k <= 5 - i;k++) { //打印前面的空格
				System.out.print(" ");
			}
			for(j = 1;j <= 2 * i - 1;j++) {	
				if(j == 1 || j == 2 * i - 1 || i == 5) { 
					//只有第一个和最后一个位置是*，以及第五层是*
			System.out.print("*");	//打印每层星数
		}else {
			System.out.print(" ");
		}
			}
			System.out.println("");	//换行
		}
	}
}
```

0140

如图 break label1,则是直接终止图中两个循环了

![image-20230417202207929](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230417202207929.png)

0142

![image-20230417214440752](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230417214440752.png)

判断字符串是否吻合的函数equals

0146

<img src="C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230419183008581.png" alt="image-20230419183008581" style="zoom:50%;" />

0152

```java
public class Homework08{
	public static void main(String[]args){
		double sum = 0;
		for(int n = 1; n <= 100;n++) {
			if(n % 2 ==0) {
				sum -= 1.0 / n;
			}else{			
			sum += 1.0 / n;
			}
	}
		System.out.println(sum);
	}
}
```

0156

![image-20230421153716362](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230421153716362.png)

![image-20230421154459376](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230421154459376.png)0161

![image-20230421182726192](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230421182726192.png)0162

![image-20230421184549385](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230421184549385.png)

0164

引用传递是地址

![image-20230421215950998](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230421215950998.png)

0165

数组拷贝

![image-20230421221005510](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230421221005510.png)

0166

将数组的数据颠倒

![image-20230421223206053](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230421223206053.png)

0167

逆序赋值

![image-20230422100014685](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230422100014685.png)

0168

![image-20230422103610639](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230422103610639.png)

0169

回答0168的第三问

```java
import java.util.Scanner;
public class ArrayAdd{
	public static void main(String[]args){
	int[] arr = {1,2,3};
	do{	
		int[] arrNew = new int[arr.length + 1];
		System.out.println("输入你的元素");
		Scanner scanner = new Scanner(System.in);
		int addNum = scanner.nextInt();
		arrNew[arrNew.length - 1] = addNum;
		for(int i = 0;i < arr.length;i++) {
			arrNew[i] = arr[i];
		}
		arr = arrNew;
		for(int i = 0;i < arr.length;i++) {
				System.out.print(arr[i] + " ");
			}
		System.out.println("是否继续，y/n");
		char key = ' ';
		key = scanner.next().charAt(0);
		if(key == 'n') {
			break;
		}
		}while(true);
	}
}
```

0174

提问：假如没有找到，怎么提示没有找到

答：用一个变量index来记录，假若index在过程没有发生变化，就说明没有找到。

```java
import java.util.Scanner;
public class SeqSearch{
	public static void main(String[]args){
		String[] names = {"小白" ,"小黑","小黄"};
		System.out.println("输入名字");
		String findName = "";
		Scanner scanner = new Scanner(System.in);
		findName = scanner.next();
		int index = -1;
		for(int i = 0;i < 3;i++) {
			if(names[i].equals(findName)){
				System.out.println("找到了，下标是" + i);
				index = i;
				break;
			}
		}
		if(index == -1) {
			System.out.println("没有找到，可惜...");
		}
	}
}

```

0175

![image-20230422172330729](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230422172330729.png)

0176

二维数组的内存形式

![image-20230422174403118](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230422174403118.png)

0178

动态初始化——列数不确定![image-20230422181025783](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230422181025783.png)

![image-20230422180737423](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230422180737423.png)

0181

![image-20230422203150161](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230422203150161.png)

```java
int[][] yangHui = new int[12][];
for(int i = 0; i < yangHui.length; i++) {//遍历 yangHui 的每个元素
    //给每个一维数组(行) 开空间
    yangHui[i] = new int[i+1];
    //给每个一维数组(行) 赋值
    for(int j = 0; j < yangHui[i].length; j++){
        //每一行的第一个元素和最后一个元素都是 1
        if(j == 0 || j == yangHui[i].length - 1) {
            yangHui[i][j] = 1;
        } else {//中间的元素
            yangHui[i][j] = yangHui[i-1][j] + yangHui[i-1][j-1];
        }
    }
}
//输出杨辉三角
for(int i = 0; i < yangHui.length; i++) {
    for(int j = 0; j < yangHui[i].length; j++) {//遍历输出该行
        System.out.print(yangHui[i][j] + "\t");
    }
    System.out.println();//换行. }
}
```

0184

![image-20230422214716755](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230422214716755.png)

![image-20230422215003641](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230422215003641.png)

0187

![image-20230422222650461](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230422222650461.png)

![image-20230422222812234](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230422222812234.png)不行就画内存图理解

![image-20230422222539890](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230422222539890.png)

到0187

生成1—100中十个随机数：![image-20230423142658957](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230423142658957.png)

```java
int[] arr = new int[10];
		for(int i = 0;i <arr.length;i++) {
		arr[i] = (int)(Math.random() * 100) + 1;
	}
```



查找最大值，顺便实现求和

```ja
int sum = arr[0];
	int max = arr[0];
	int index = 0;
	for(int i = 1; i < arr.length;i++) {
		sum += arr[i];
		if(max < arr[i]) {
			max =arr[i];
			index = i; 
		}
	}
	System.out.println("\n最大值" + max +"下标为" + index + "平均值" + sum / arr.length);
```



查找数字8

![image-20230423150957898](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230423150957898.png)

0192

![image-20230423180202618](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230423180202618.png)

0194

![](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230423211057585.png)

0196

![image-20230423220045023](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230423220045023.png)

0199

![image-20230424080010626](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230424080010626.png)

![image-20230424080443617](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230424080443617.png)

0203

![image-20230424151502984](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230424151502984.png)

![image-20230424151834629](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230424151834629.png)

返回后原来的栈就销毁了

![image-20230424152214992](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230424152214992.png)

 

0208

<img src="C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230427152412436.png" alt="image-20230427152412436" style="zoom:50%;" />

<img src="C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230427152750192.png" alt="image-20230427152750192" style="zoom:50%;" />

0210

![image-20230427222639855](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230427222639855.png)

0212

**引用传递本质只是把地址复制给了新代表，并没有其他意思**

0213

**为什么调用一个类的方法首先要创造一个这个类的对象？**

在Java中，一个类是一组共享相同属性和行为的对象的蓝图或模板。在调用类的方法时，
需要使用该类的对象来执行方法。这是因为方法是与对象相关联的，
它们包含对对象属性的引用和对对象行为的定义。

当你创建一个类的对象时，你实际上是在创建该类的一个实例。这个实例包含了该类中定义的所有属性和方法，
并且可以通过该实例来访问和操作这些属性和方法。因此，在调用类的方法时，你需要先创建该类的一个实例，
然后使用该实例来调用该类的方法。

举个例子，假设你有一个名为Person的类，该类包含一个名为getName()的方法，
用于获取该人的姓名。如果你想调用这个方法来获取某个人的姓名，你需要先创建一个Person对象，
然后使用该对象来调用getName()方法，如下所示：

java
Copy
Person person = new Person(); // 创建一个Person对象
String name = person.getName(); // 使用该对象调用getName()方法
因此，创建一个类的对象是调用该类方法的必要步骤。

0215

![image-20230429095144767](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230429095144767.png)

**每一个栈都是完整执行所有的代码**

 0217

递归调用实现阶乘

![image-20230429110339031](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230429110339031.png)

ps:递归调用就是层层放下去，然后从下面逐渐累积上来的过程

- 怎么样才能搞懂递归算法，我怎么知道什么时候我该用递归算法解决需求？

  递归算法是一种通过调用自身函数来解决问题的算法，其中很多经典的问题可以用递归算法来实现，比如计算一个数的阶乘、斐波那契数列等。当我们需要解决的问题本身就是递归的，那么使用递归算法会更加自然和简洁。

  一般来说，如果问题本质上可以分解为相似的子问题，而每个子问题可以通过对自身的递归求解得到答案，那么就可以考虑使用递归算法。

  递归算法存在一些缺点，比如可能导致栈溢出、重复计算等问题。因此在实际应用中需要考虑算法复杂度和可行性。

  为了搞懂递归算法，建议多理解递归的本质特点，尽量通过实际的例子和练习来加深理解。在编程实现时，可以画图或者手工模拟递归的执行过程，加深对递归思想的理解。

0222

迷宫换ide 调试一遍

塔问题，八皇后问题统统回看懒猫老师讲解

0234

int []类型不能自动转换成double []类型

0238

![image-20230502095453720](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230502095453720.png)

![image-20230502095527252](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230502095527252.png)

0239

![image-20230503085808745](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230503085808745.png)

![image-20230503085929252](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230503085929252.png)

![image-20230503090432630](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230503090432630.png)

![image-20230503095319587](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230503095319587.png)

![image-20230503111454119](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230503111454119.png)

0247

![image-20230506103137137](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230506103137137.png)

![image-20230506110607096](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230506110607096.png)

0249

用this访问一个构造器只能在构造器里访问，并且this语句必须放在第一行

![](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230506113820561.png)

![image-20230506115109375](C:\Users\Zrz14\AppData\Roaming\Typora\typora-user-images\image-20230506115109375.png)

0250

```java
public class TestPerson {

	public static void main(String[] args) {
		Person p1 = new Person("好好",20);
		Person p2 = new Person();
		System.out.println(p1.compareTo(p2));
	}
}

class Person{
	String name = "小小";
	int age = 10;

public Person(){

}

	/*
	1.写一个构造器，形参接收，将信息赋给属性;

	*/
public Person(String name,int age){
	this.name = name;
	this.age = age; 
}
	/*
	1.首先写一个比较方法，返回类型是boolean,内容是
	比较给的两个属性信息，直接return结果
	2.怎么传入两个属性？需要两个对象，
	*/
public boolean compareTo(Person p2){
	return this.name.equals(p2.name) && this.age == p2.age;
}
}
```

我有一个教训：为什么当初我创建p2对象时会报错，因为我原先已经创建了一个有参构造器，代替了无参构造器。所以创建p2时参数类型不匹配导致报错了，后来我又加入了一个无参构造器public Person(){ }，使得p2匹配成功，结果就没问题了，而默认无参构造器也正对应着属性信息.

或者我也可以创建p2对象时，像p1那样给他参数，使他对应有参构造器也行。

0251

实现代码健壮化

```java
public class Homework01 {

	public static void main(String[] args) {
		double[] arr = {};
		A01 p1 = new A01();
		Double res = p1.max(arr);
		if(res != null){
			System.out.println(p1.max(arr));
		}else{
			System.out.println("arr输入有误");
		}
	}
}

class A01{


	public Double max(double[] arr) {
		if(arr != null && arr.length > 0){
		double max = arr[0]; 
			for(int i = 1;i < arr.length;i++) {
				if(max < arr[i]){
					max = arr[i];
				}
			}
			return max;
		}else{
			return null;
		}
	}
}
```



到0253

